(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{431:function(e,t,a){"use strict";a.r(t);var n=a(44),o=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"transform-two-schemas-into-one"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#transform-two-schemas-into-one"}},[e._v("#")]),e._v(" Transform Two Schemas Into One")]),e._v(" "),a("h2",{attrs:{id:"example-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#example-1"}},[e._v("#")]),e._v(" Example 1")]),e._v(" "),a("p",[e._v("Assume we have schema of api.concepts.json and a schema of\nusability.concepts.json, and we need to transform them into\nedit-page.concepts.json using a transformation.")]),e._v(" "),a("h2",{attrs:{id:"example-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#example-2"}},[e._v("#")]),e._v(" Example 2")]),e._v(" "),a("p",[e._v("You have a schema generated from reflection data. You want to generate a code\nfrom that, but reflection data does not have enough information. You need\nanother data to use to generate. So again, three concepts, two schemas in, one\nschema out.")]),e._v(" "),a("p",[a("code",[e._v("greeting.business.json")]),e._v(" + "),a("code",[e._v("greeting.routing.json")]),e._v(" -> "),a("code",[e._v("greeting.api.json")])]),e._v(" "),a("h2",{attrs:{id:"example-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#example-3"}},[e._v("#")]),e._v(" Example 3")]),e._v(" "),a("p",[e._v("Having both definition, and documentation in the same specification is hard to\nmaintain. With this feature, you can have;")]),e._v(" "),a("p",[a("code",[e._v("greeting.api.json")]),e._v(" + "),a("code",[e._v("greeting.documentation.json")]),e._v(" ->\n"),a("code",[e._v("greeting.swagger.json")])])])}),[],!1,null,null,null);t.default=o.exports}}]);
(self.webpackChunkjson_concepts=self.webpackChunkjson_concepts||[]).push([[8939],{9156:(e,a,t)=>{"use strict";t.r(a),t.d(a,{data:()=>n});const n={key:"v-48258e3d",path:"/proposals/XX-transform-two-schemas-into-one.html",title:"Transform Two Schemas Into One",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"Example 1",slug:"example-1",children:[]},{level:2,title:"Example 2",slug:"example-2",children:[]},{level:2,title:"Example 3",slug:"example-3",children:[]}],filePathRelative:"proposals/XX-transform-two-schemas-into-one.md"}},3262:(e,a,t)=>{"use strict";t.r(a),t.d(a,{default:()=>o});const n=(0,t(6252).uE)('<h1 id="transform-two-schemas-into-one" tabindex="-1"><a class="header-anchor" href="#transform-two-schemas-into-one" aria-hidden="true">#</a> Transform Two Schemas Into One</h1><blockquote><p>TBD - use case</p></blockquote><h2 id="example-1" tabindex="-1"><a class="header-anchor" href="#example-1" aria-hidden="true">#</a> Example 1</h2><p>Assume we have schema of api.concepts.json and a schema of usability.concepts.json, and we need to transform them into edit-page.concepts.json using a transformation.</p><h2 id="example-2" tabindex="-1"><a class="header-anchor" href="#example-2" aria-hidden="true">#</a> Example 2</h2><p>You have a schema generated from reflection data. You want to generate a code from that, but reflection data does not have enough information. You need another data to use to generate. So again, three concepts, two schemas in, one schema out.</p><p><code>greeting.business.json</code> + <code>greeting.routing.json</code> -&gt; <code>greeting.api.json</code></p><h2 id="example-3" tabindex="-1"><a class="header-anchor" href="#example-3" aria-hidden="true">#</a> Example 3</h2><p>Having both definition, and documentation in the same specification is hard to maintain. With this feature, you can have;</p><p><code>greeting.api.json</code> + <code>greeting.documentation.json</code> -&gt; <code>greeting.swagger.json</code></p>',10),o={render:function(e,a){return n}}}}]);
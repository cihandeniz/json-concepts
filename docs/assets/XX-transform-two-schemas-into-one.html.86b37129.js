import{_ as e,d as a}from"./app.7ccd3bcb.js";const o={},n=a('<h1 id="transform-two-schemas-into-one" tabindex="-1"><a class="header-anchor" href="#transform-two-schemas-into-one" aria-hidden="true">#</a> Transform Two Schemas Into One</h1><blockquote><p>TBD - use case</p></blockquote><h2 id="example-1" tabindex="-1"><a class="header-anchor" href="#example-1" aria-hidden="true">#</a> Example 1</h2><p>Assume we have schema of api.concepts.json and a schema of usability.concepts.json, and we need to transform them into edit-page.concepts.json using a transformation.</p><h2 id="example-2" tabindex="-1"><a class="header-anchor" href="#example-2" aria-hidden="true">#</a> Example 2</h2><p>You have a schema generated from reflection data. You want to generate a code from that, but reflection data does not have enough information. You need another data to use to generate. So again, three concepts, two schemas in, one schema out.</p><p><code>greeting.business.json</code> + <code>greeting.routing.json</code> -&gt; <code>greeting.api.json</code></p><h2 id="example-3" tabindex="-1"><a class="header-anchor" href="#example-3" aria-hidden="true">#</a> Example 3</h2><p>Having both definition, and documentation in the same specification is hard to maintain. With this feature, you can have;</p><p><code>greeting.api.json</code> + <code>greeting.documentation.json</code> -&gt; <code>greeting.swagger.json</code></p>',10);function t(s,r){return n}var c=e(o,[["render",t],["__file","XX-transform-two-schemas-into-one.html.vue"]]);export{c as default};
